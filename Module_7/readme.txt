Module_7_1
Цель: закрепить знания о работе с файлами (чтение/запись) решив задачу.

Задача "Учёт товаров".

Необходимо реализовать 2 класса Product и Shop, с помощью которых будет производиться запись в файл с продуктами.
Объекты класса Product будут создаваться следующим образом - Product('Potato', 50.0, 'Vegetables') и обладать следующими свойствами:
1. Атрибут name - название продукта (строка).
2. Атрибут weight - общий вес товара (дробное число) (5.4, 52.8 и т.п.).
3. Атрибут category - категория товара (строка).
4. Метод __str__, который возвращает строку в формате '<название>, <вес>, <категория>'. Все данные в строке разделены запятой с пробелами.

Объекты класса Shop будут создаваться следующим образом - Shop() и обладать следующими свойствами:
1. Инкапсулированный атрибут __file_name = 'products.txt'.
2. Метод get_products(self), который считывает всю информацию из файла __file_name, закрывает его и возвращает единую строку со всеми товарами из файла __file_name.
3. Метод add(self, *products), который принимает неограниченное количество объектов класса Product. Добавляет в файл __file_name каждый продукт из products, если его ещё нет в файле (по полю name и по полю category).
Если такой продукт уже есть, то увеличивает общий вес и выводит строку 'Продукт <название> уже был в магазине, его общий вес теперь равен <вес>'.

Пример результата выполнения программы:
Пример работы программы:
s1 = Shop()
p1 = Product('Potato', 50.5, 'Vegetables')
p2 = Product('Spaghetti', 3.4, 'Groceries')
p3 = Product('Potato', 5.5, 'Vegetables')
s1.add(p1, p2, p3)
print(s1.get_products())

Вывод на консоль:
Potato, 50.5, Vegetables
Spaghetti, 3.4, Groceries
Продукт Potato уже был в магазине, его общий вес теперь равен 56.0

Примечания:
1. Не забывайте при записи в файл добавлять спец. символ перехода на следующую строку в конце - '\n'.
2. При проверке на существование товара в методе add можно вызывать метод get_products для получения текущих продуктов.
3. Не забывайте закрывать файл вызывая метод close() у объектов файла.


Module_7_2
Цель: Закрепить знания о позиционировании в файле, использовав метод tell() файлового объекта. Написать усовершенствованную функцию записи.

Задача "Записать и запомнить".

Создать функцию custom_write(file_name, strings), которая принимает следующие аргументы:
1. file_name - название файла для записи.
2. strings - список строк для записи.

Функция должна:
1. Записывать в файл file_name все строки из списка strings, каждая на новой строке.
2. Возвращать словарь strings_positions, где ключом будет кортеж (<номер строки>, <байт начала строки>), а значением - записываемая строка.
Для получения номера байта начала строки используйте метод tell() перед записью.

Пример полученного словаря:
{(1, 0): 'Text for tell.', (2, 16): 'Используйте кодировку utf-8.'}
Где:
1, 2 - номера записанных строк.
0, 16 - номера байт, на которых началась запись строк.
'Text for tell.', 'Используйте кодировку utf-8.' - сами строки.

Пример результата выполнения программы:
Пример выполняемого кода:
info = ['Text for tell.',
        'Используйте кодировку utf-8.',
        'Because there are 2 languages!',
        'Спасибо!'
       ]
result = custom_write('test.txt', info)
for elem in result.items():
  print(elem)

Вывод на консоль:
((1, 0), 'Text for tell.')
((2, 16), 'Используйте кодировку utf-8.')
((3, 66), 'Because there are 2 languages!')
((4, 98), 'Спасибо!')

Примечания:
1. Не забывайте при записи в файл добавлять спец. символ перехода на следующую строку в конце - '\n'.
2. Не забывайте закрывать файл вызывая метод close() у объектов файла.
3. Помните, что при использовании символов не принадлежащих таблице ASCII, вы используете больше байт для записи символа.
Соответственно для чтения и записи информации из/в файл(-f) потребуется другая кодировка - utf-8.


Module_7_3
Цель: применить на практике оператор with, вспомнить написание кода в парадигме ООП.

Задача "Найдёт везде".

Напишите класс WordsFinder, объекты которого создаются следующим образом:
WordsFinder('file1.txt, file2.txt', 'file3.txt', ...).
Объект этого класса должен принимать при создании неограниченного количество названий файлов и записывать их в атрибут file_names в виде списка или кортежа.
Также объект класса WordsFinder должен обладать следующими методами:
1. get_all_words - подготовительный метод, который возвращает словарь следующего вида:
{'file1.txt': ['word1', 'word2'], 'file2.txt': ['word3', 'word4'], 'file3.txt': ['word5', 'word6', 'word7']}
Где:
'file1.txt', 'file2.txt', ''file3.txt'' - названия файлов.
['word1', 'word2'], ['word3', 'word4'], ['word5', 'word6', 'word7'] - слова содержащиеся в этом файле.
Алгоритм получения словаря такого вида в методе get_all_words:
а) Создайте пустой словарь all_words.
б) Переберите названия файлов и открывайте каждый из них, используя оператор with.
в) Для каждого файла считывайте единые строки, переводя их в нижний регистр (метод lower()).
г) Избавьтесь от пунктуации [',', '.', '=', '!', '?', ';', ':', ' - '] в строке (тире обособлено пробелами, это не дефис в слове).
д) Разбейте эту строку на элементы списка методом split() (разбивается по умолчанию по пробелу).
е) В словарь all_words запишите полученные данные, ключ - название файла, значение - список из слов этого файла.
2. find(self, word) - метод, где word - искомое слово. Возвращает словарь, где ключ - название файла, значение - позиция первого такого слова в списке слов этого файла.
3. count(self, word) - метод, где word - искомое слово. Возвращает словарь, где ключ - название файла, значение - количество слова word в списке слов этого файла.
В методах find и count пользуйтесь ранее написанным методом get_all_words для получения названия файла и списка его слов.
Для удобного перебора одновременно ключа(названия) и значения(списка слов) можно воспользоваться методом словаря - item().
for name, words in get_all_words().items():

Логика методов find или count
Пример результата выполнения программы:
Представим, что файл 'test_file.txt' содержит следующий текст:
It's a text for task Найти везде,
Используйте его для самопроверки.
Успехов в решении задачи!
text text text

Пример выполнения программы:
finder2 = WordsFinder('test_file.txt')
print(finder2.get_all_words()) # Все слова
print(finder2.find('TEXT')) # 3 слово по счёту
print(finder2.count('teXT')) # 4 слова teXT в тексте всего

Вывод на консоль:
{'test_file.txt': ["it's", 'a', 'text', 'for', 'task', 'найти', 'везде', 'используйте', 'его', 'для', 'самопроверки', 'успехов', 'в', 'решении', 'задачи', 'text', 'text', 'text']}
{'test_file.txt': 3}
{'test_file.txt': 4}

Запустите этот код с другими предложенными примерами.
Если решение верное, то результаты должны совпадать с предложенными.

Примечания:
1. Регистром слов при поиске можно пренебречь ('teXT' ~ 'text').
2. Решайте задачу последовательно - написав один метод, проверьте результаты его работы.


Module_7_4
Цель задания: освоить различные методы форматирования строк в Python.
Научиться применять эти методы в контексте описания соревнования.
История: соперничество двух команд - Мастера кода и Волшебники данных.

Задание:
1. Создайте новый проект или продолжите работу в текущем проекте.
2. Напишите код, который форматирует строки для следующих сценариев.
3. Укажите переменные, которые должны быть вставлены в каждую строку.

Использование %:
1. Переменные: количество участников первой команды (team1_num).
Пример итоговой строки: "В команде Мастера кода участников: 5!"
2. Переменные: количество участников в обеих командах (team1_num, team2_num).
Пример итоговой строки: "Итого сегодня в командах участников: 5 и 6!"

Использование format():
1. Переменные: количество задач решённых командой 2 (score_2).
Пример итоговой строки: "Команда Волшебники данных решила задач: 42!"
2. Переменные: время за которое команда 2 решила задачи (team1_time).
Пример итоговой строки: "Волшебники данных решили задачи за 18015.2 с!"

Использование f-строк:
1. Переменные: количество решённых задач по командам: score_1, score_2.
Пример итоговой строки: "Команды решили 40 и 42 задач".
2. Переменные: исход соревнования (challenge_result).
Пример итоговой строки: "Результат битвы: победа команды Мастера кода!"
3. Переменные: количество задач (tasks_total) и среднее время решения (time_avg).
Пример итоговой строки: "Сегодня было решено 82 задач, в среднем по 350.4 секунды на задачу!".

Комментарии к заданию:
1. В русском языке окончания слов меняются (1 участник, 2 участника), пока что давайте не обращать на это внимания.
2. Переменные challenge_result, tasks_total, time_avg можно задать вручную или рассчитать. Например, для challenge_result:
if score_1 > score_2 or score_1 == score_2 and team1_time > team2_time:
result = ‘Победа команды Мастера кода!’
elif score_1 < score_2 or score_1 == score_2 and team1_time < team2_time:
result = ‘Победа команды Волшебники Данных!’
else:
result = ‘Ничья!’

Пример входных данных
team1_num = 5
team2_num = 6
score_1 = 40
score_2 = 42
team1_time = 1552.512
team2_time = 2153.31451
tasks_total = 82
time_avg = 45.2
challenge_result = 'Победа команды Волшебники данных!'


Module_7_5
Цель задания: освоить работу с файловой системой в Python, используя модуль os.
Научиться применять методы os.walk, os.path.join, os.path.getmtime, os.path.dirname, os.path.getsize и использование модуля time для корректного отображения времени.

Задание:
1. Создайте новый проект или продолжите работу в текущем проекте.
2. Используйте os.walk для обхода каталога, путь к которому указывает переменная directory.
3. Примените os.path.join для формирования полного пути к файлам.
4. Используйте os.path.getmtime и модуль time для получения и отображения времени последнего изменения файла.
5. Используйте os.path.getsize для получения размера файла.
6. Используйте os.path.dirname для получения родительской директории файла.

Комментарии к заданию:
1. Ключевая идея – использование вложенного for.
for root, dirs, files in os.walk(directory):
    for file in files:
        filepath = ?
        filetime = ?
        formatted_time = time.strftime("%d.%m.%Y %H:%M", time.localtime(filetime))
        filesize = ?
        parent_dir = ?
        print(f'Обнаружен файл: {file}, Путь: {filepath}, Размер: {filesize} байт,
        Время изменения: {formatted_time}, Родительская директория: {parent_dir}')

2. Так как в разных операционных системах разная схема расположения папок, тестировать проще всего в папке проекта (directory = “.”)

Пример возможного вывода:
Обнаружен файл: main.py, Путь: ./main.py, Размер: 111 байт, Время изменения: 11.11.1111 11:11, Родительская директория.